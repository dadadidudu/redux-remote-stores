{"version":3,"sources":["../src/index.js"],"names":["close","message","open","addConnectionToBridge","removeConnectionFromBridge","removeAllConnectionsFromBridge","createWebSocketMiddleware","trimUndefined","CLOSE","MESSAGE","OPEN","SEND","type","payload","webSockets","storeRef","options","websocketOrUrl","websocket","WebSocket","initWebSocket","push","wsIndex","findIndex","ws","readyState","CLOSING","CLOSED","splice","forEach","DEFAULT_OPTIONS","binaryType","fold","action","webSocket","meta","arrayify","send","some","actionWithoutMeta","JSON","stringify","namespace","unfold","raw","tryParseJSON","obj","Array","isArray","customOptions","toLowerCase","store","next","json","parse","err","map","Object","keys","reduce","nextMap","key","value","onopen","dispatch","onclose","onmessage","getPayload","Blob","event","data","ArrayBuffer","Promise","resolve","then","Error"],"mappings":"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","file":"index.js","sourcesContent":["import blobToArrayBuffer from './blobToArrayBuffer';\r\nimport isFSA             from './isFSA';\r\n\r\nexport const CLOSE   = `CLOSE`;\r\nexport const MESSAGE = `MESSAGE`;\r\nexport const OPEN    = `OPEN`;\r\nexport const SEND    = `SEND`;\r\n\r\nexport function close() {\r\n  return { type: CLOSE };\r\n}\r\n\r\nexport function message(payload) {\r\n  return { type: MESSAGE, payload }\r\n}\r\n\r\nexport function open() {\r\n  return { type: OPEN };\r\n}\r\n\r\nlet webSockets = [];\r\nlet storeRef;\r\nlet options;\r\n\r\nexport function addConnectionToBridge(websocketOrUrl) {\r\n  let websocket;\r\n\r\n  if (typeof websocketOrUrl === \"string\")\r\n    websocket = new WebSocket(websocketOrUrl);\r\n  else\r\n    websocket = websocketOrUrl;\r\n\r\n  initWebSocket(websocket, storeRef);\r\n  webSockets.push(websocket);\r\n}\r\n\r\nexport function removeConnectionFromBridge(websocket) {\r\n\r\n  let wsIndex = webSockets.findIndex(ws => ws === websocket);\r\n\r\n  if (wsIndex > -1) {\r\n    if (websocket.readyState !== websocket.CLOSING ||\r\n        websocket.readyState !== websocket.CLOSED)\r\n      webSockets[wsIndex].close();\r\n    webSockets.splice(wsIndex, 1);\r\n  }\r\n}\r\n\r\nexport function removeAllConnectionsFromBridge() {\r\n  webSockets.forEach(ws => ws.close());\r\n  webSockets = [];\r\n}\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  binaryType: 'arraybuffer',\r\n  fold      : (action, webSocket) => {\r\n    if (action.meta && arrayify(action.meta.send).some(send => send === true || send === webSocket)) {\r\n      const { meta, ...actionWithoutMeta } = action;\r\n\r\n      return JSON.stringify(actionWithoutMeta);\r\n    }\r\n  },\r\n  meta      : {},\r\n  namespace : '@@websocket/',\r\n  unfold   : (payload, webSocket, raw) => {\r\n    const action = tryParseJSON(payload);\r\n\r\n    return action && {\r\n      ...action,\r\n      meta: {\r\n        ...action.meta,\r\n        webSocket\r\n      }\r\n    };\r\n  }\r\n};\r\n\r\nfunction arrayify(obj) {\r\n  return obj ? Array.isArray(obj) ? obj : [obj] : [];\r\n}\r\n\r\nexport default function createWebSocketMiddleware(customOptions = DEFAULT_OPTIONS) {\r\n  options = { ...DEFAULT_OPTIONS, ...customOptions };\r\n  options.binaryType = customOptions.binaryType.toLowerCase();\r\n  options.unfold = customOptions.unfold && (typeof customOptions.unfold === 'function' ? customOptions.unfold : DEFAULT_OPTIONS.unfold);\r\n\r\n  const { namespace } = options;\r\n\r\n  return store => {\r\n    storeRef = store;\r\n\r\n    return next => action => {\r\n      if (action.type === `${ namespace }${ SEND }`) {\r\n        webSockets.forEach(webSocket => webSocket.send(action.payload));\r\n      } else {\r\n        webSockets.forEach(webSocket => {\r\n          const payload = options.fold(action, webSocket);\r\n          payload && webSocket.send(payload);\r\n        })\r\n      }\r\n\r\n      return next(action);\r\n    };\r\n  };\r\n}\r\n\r\nfunction tryParseJSON(json) {\r\n  try {\r\n    return JSON.parse(json);\r\n  } catch (err) {}\r\n}\r\n\r\nexport function trimUndefined(map) {\r\n  return Object.keys(map).reduce((nextMap, key) => {\r\n    const value = map[key];\r\n\r\n    if (typeof value !== 'undefined') {\r\n      nextMap[key] = value;\r\n    }\r\n\r\n    return nextMap;\r\n  }, {});\r\n}\r\n\r\nfunction initWebSocket(webSocket, store) {\r\n  webSocket.onopen = () => store.dispatch({ type: `${options.namespace}${OPEN}`, meta: { webSocket } });\r\n  webSocket.onclose = () => store.dispatch({ type: `${options.namespace}${CLOSE}`, meta: { webSocket } });\r\n  webSocket.onmessage = event => {\r\n    let getPayload;\r\n\r\n    if (typeof Blob !== 'undefined' && options.binaryType === 'arraybuffer' && event.data instanceof Blob) {\r\n      getPayload = blobToArrayBuffer(event.data);\r\n    } else if (typeof ArrayBuffer !== 'undefined' && options.binaryType === 'blob' && event.data instanceof ArrayBuffer) {\r\n      getPayload = new Blob([event.data]);\r\n    } else {\r\n      // We make this a Promise because we might want to keep the sequence of dispatch, @@websocket/MESSAGE first, then unfold later.\r\n      getPayload = Promise.resolve(event.data);\r\n    }\r\n\r\n    return getPayload.then(payload => {\r\n      if (options.unfold) {\r\n        const action = options.unfold(payload, webSocket, payload);\r\n\r\n        if (action) {\r\n          if (!isFSA(action)) {\r\n            throw new Error('Unfolded action is not a Flux Standard Action compliant');\r\n          }\r\n\r\n          return action && store.dispatch(action);\r\n        }\r\n      }\r\n\r\n      store.dispatch({\r\n        type: `${options.namespace}${MESSAGE}`,\r\n        meta: { webSocket },\r\n        payload\r\n      });\r\n    });\r\n  }\r\n}\r\n"]}