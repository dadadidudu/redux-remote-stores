{"version":3,"sources":["../src/index.js"],"names":["close","message","open","addConnectionToStore","removeConnectionFromStore","removeAllConnectionsFromStore","createWebSocketMiddleware","trimUndefined","CLOSE","MESSAGE","OPEN","SEND","type","payload","webSockets","storeRef","options","websocketOrUrl","websocket","WebSocket","undefined","Error","initWebSocket","push","wsIndex","findIndex","ws","readyState","CLOSING","CLOSED","splice","forEach","DEFAULT_OPTIONS","binaryType","fold","action","webSocket","meta","arrayify","send","some","actionWithoutMeta","JSON","stringify","namespace","unfold","raw","tryParseJSON","obj","Array","isArray","customOptions","toLowerCase","store","next","json","parse","err","map","Object","keys","reduce","nextMap","key","value","onopen","dispatch","onclose","onmessage","getPayload","Blob","event","data","ArrayBuffer","Promise","resolve","then"],"mappings":"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","file":"index.js","sourcesContent":["import blobToArrayBuffer from './blobToArrayBuffer';\r\nimport isFSA             from './isFSA';\r\n\r\nexport const CLOSE   = `CLOSE`;\r\nexport const MESSAGE = `MESSAGE`;\r\nexport const OPEN    = `OPEN`;\r\nexport const SEND    = `SEND`;\r\n\r\nexport function close() {\r\n  return { type: CLOSE };\r\n}\r\n\r\nexport function message(payload) {\r\n  return { type: MESSAGE, payload }\r\n}\r\n\r\nexport function open() {\r\n  return { type: OPEN };\r\n}\r\n\r\nlet webSockets = [];\r\nlet storeRef;\r\nlet options;\r\n\r\nexport function addConnectionToStore(websocketOrUrl) {\r\n  let websocket;\r\n\r\n  if (typeof websocketOrUrl === \"string\")\r\n    websocket = new WebSocket(websocketOrUrl);\r\n  else\r\n    websocket = websocketOrUrl;\r\n\r\n  if (storeRef === undefined)\r\n    throw new Error(\"Redux store must be set up before adding connections.\");\r\n\r\n  initWebSocket(websocket, storeRef);\r\n  webSockets.push(websocket);\r\n}\r\n\r\nexport function removeConnectionFromStore(websocket) {\r\n\r\n  let wsIndex = webSockets.findIndex(ws => ws === websocket);\r\n\r\n  if (wsIndex > -1) {\r\n    if (websocket.readyState !== websocket.CLOSING ||\r\n        websocket.readyState !== websocket.CLOSED)\r\n      webSockets[wsIndex].close();\r\n    webSockets.splice(wsIndex, 1);\r\n  }\r\n}\r\n\r\nexport function removeAllConnectionsFromStore() {\r\n  webSockets.forEach(ws => ws.close());\r\n  webSockets = [];\r\n}\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  binaryType: 'arraybuffer',\r\n  fold      : (action, webSocket) => {\r\n    if (action.meta && arrayify(action.meta.send).some(send => send === true || send === webSocket)) {\r\n      const { meta, ...actionWithoutMeta } = action;\r\n\r\n      return JSON.stringify(actionWithoutMeta);\r\n    }\r\n  },\r\n  meta      : {},\r\n  namespace : '@@websocket/',\r\n  unfold   : (payload, webSocket, raw) => {\r\n    const action = tryParseJSON(payload);\r\n\r\n    return action && {\r\n      ...action,\r\n      meta: {\r\n        ...action.meta,\r\n        webSocket\r\n      }\r\n    };\r\n  }\r\n};\r\n\r\nfunction arrayify(obj) {\r\n  return obj ? Array.isArray(obj) ? obj : [obj] : [];\r\n}\r\n\r\nexport function createWebSocketMiddleware(customOptions = DEFAULT_OPTIONS) {\r\n  options = { ...DEFAULT_OPTIONS, ...customOptions };\r\n  options.binaryType = customOptions.binaryType.toLowerCase();\r\n  options.unfold = customOptions.unfold && (typeof customOptions.unfold === 'function' ? customOptions.unfold : DEFAULT_OPTIONS.unfold);\r\n\r\n  return store => {\r\n    storeRef = store;\r\n\r\n    return next => action => {\r\n      if (action.type === `${ options.namespace }${ SEND }`) {\r\n        webSockets.forEach(webSocket => webSocket.send(action.payload));\r\n      } else {\r\n        webSockets.forEach(webSocket => {\r\n          const payload = options.fold(action, webSocket);\r\n          payload && webSocket.send(payload);\r\n        })\r\n      }\r\n\r\n      return next(action);\r\n    };\r\n  };\r\n}\r\n\r\nfunction tryParseJSON(json) {\r\n  try {\r\n    return JSON.parse(json);\r\n  } catch (err) {}\r\n}\r\n\r\nexport function trimUndefined(map) {\r\n  return Object.keys(map).reduce((nextMap, key) => {\r\n    const value = map[key];\r\n\r\n    if (typeof value !== 'undefined') {\r\n      nextMap[key] = value;\r\n    }\r\n\r\n    return nextMap;\r\n  }, {});\r\n}\r\n\r\nfunction initWebSocket(webSocket, store) {\r\n  webSocket.onopen = () => store.dispatch({ type: `${options.namespace}${OPEN}`, meta: { webSocket } });\r\n  webSocket.onclose = () => store.dispatch({ type: `${options.namespace}${CLOSE}`, meta: { webSocket } });\r\n  webSocket.onmessage = event => {\r\n    let getPayload;\r\n\r\n    if (typeof Blob !== 'undefined' && options.binaryType === 'arraybuffer' && event.data instanceof Blob) {\r\n      getPayload = blobToArrayBuffer(event.data);\r\n    } else if (typeof ArrayBuffer !== 'undefined' && options.binaryType === 'blob' && event.data instanceof ArrayBuffer) {\r\n      getPayload = new Blob([event.data]);\r\n    } else {\r\n      // We make this a Promise because we might want to keep the sequence of dispatch, @@websocket/MESSAGE first, then unfold later.\r\n      getPayload = Promise.resolve(event.data);\r\n    }\r\n\r\n    return getPayload.then(payload => {\r\n      if (options.unfold) {\r\n        const action = options.unfold(payload, webSocket, payload);\r\n\r\n        if (action) {\r\n          if (!isFSA(action)) {\r\n            throw new Error('Unfolded action is not a Flux Standard Action compliant');\r\n          }\r\n\r\n          return action && store.dispatch(action);\r\n        }\r\n      }\r\n\r\n      store.dispatch({\r\n        type: `${options.namespace}${MESSAGE}`,\r\n        meta: { webSocket },\r\n        payload\r\n      });\r\n    });\r\n  }\r\n}\r\n"]}